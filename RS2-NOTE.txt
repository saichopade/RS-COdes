# Import Required Libraries
import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import linear_kernel

# Step 1: Load the Dataset
# Replace 'movie_dataset.csv' with the actual path to your dataset
movies_df = pd.read_csv('/content/drive/MyDrive/RS Practical 2/movie_dataset.csv')

# Step 2: Preprocess the Data
# Fill any missing values in the 'genres', 'overview', and 'tagline' columns
movies_df['genres'] = movies_df['genres'].fillna('')
movies_df['overview'] = movies_df['overview'].fillna('')
movies_df['tagline'] = movies_df['tagline'].fillna('')

# Combine 'genres', 'overview', and 'tagline' into a single content column
movies_df['content'] = (
    movies_df['genres'] + ' ' + movies_df['overview'] + ' ' + movies_df['tagline']
)

# Step 3: Create a TF-IDF Vectorizer and Compute the Similarity Matrix
tfidf = TfidfVectorizer(stop_words='english')
tfidf_matrix = tfidf.fit_transform(movies_df['content'])

# Compute the cosine similarity matrix
cosine_sim = linear_kernel(tfidf_matrix, tfidf_matrix)

# Step 4: Build the Recommendation Function
def get_recommendations(title, cosine_sim=cosine_sim, movies_df=movies_df):
    # Check if the movie title exists in the dataset
    if title not in movies_df['title'].values:
        return ["Movie not found in database."]

    # Get the index of the movie that matches the title
    idx = movies_df[movies_df['title'] == title].index[0]

    # Get the pairwise similarity scores of all movies with that movie
    sim_scores = list(enumerate(cosine_sim[idx]))

    # Sort the movies based on the similarity scores
    sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

    # Get the scores of the top 10 most similar movies
    sim_scores = sim_scores[1:11]  # Exclude the movie itself

    # Get the movie indices
    movie_indices = [i[0] for i in sim_scores]

    # Return the top 10 most similar movies
    return movies_df['title'].iloc[movie_indices].tolist()

# Step 5: Evaluate the Recommendation System
# Example: Get recommendations for a specific movie
movie_title = "Spectre"  # Replace with any movie title from your dataset
recommended_movies = get_recommendations(movie_title)

print(f"Recommendations for '{movie_title}':")
for movie in recommended_movies:
    print(movie)







1. Content Overview
The goal of this script is to build a recommendation system based on a dataset of IMDB Top 250 Movies. 
The script demonstrates:
Content-Based Recommendations: Recommends movies based on their attributes like genre, tagline, and cast.
Collaborative Filtering: Uses user-item interaction to find similar users and recommend movies.
Hybrid Recommendations: Combines content-based and collaborative filtering for better recommendations.

2. Dataset and Preprocessing
Dataset Loading:
The dataset (IMDB Top 250 Movies.csv) contains the following columns:
    name (Movie Name), genre, tagline, casts, and rating.
Rows with missing values are removed.

Content Creation:
A new column content is created by concatenating the genre, tagline, and casts columns. This serves as the basis for Content-Based Filtering.

3. Content-Based Filtering
Vectorization:
The content column is vectorized using TF-IDF (Term Frequency-Inverse Document Frequency). This converts text into numerical vectors that represent the importance of terms within the dataset.

Similarity Calculation:
Cosine Similarity is computed between the TF-IDF vectors of movies. This measures the similarity between two movies based on their content.

Recommendation Function:
get_content_based_recommendations(title):
    Finds the index of the input movie.
    Retrieves the similarity scores of this movie with all other movies.
    Sorts the movies by similarity and returns the top 5 similar movies.

4. Collaborative Filtering
User-Item Matrix:
A pivot table is created where:
    Rows represent movies (name).
    Columns represent unique ratings (rating).
This matrix is sparse, as not all movies have ratings for every possible value.

Latent Factor Model:
    SVD (Singular Value Decomposition) is applied to reduce the dimensionality of the user-item matrix.
    Movies are represented as lower-dimensional latent factors, capturing their essential features.

Recommendation Function:
get_collaborative_recommendations(user_id):
    Finds the latent vector of the user.
    Computes cosine distances between the user and all other users.
    Identifies similar users and recommends movies they have rated highly.

5. Hybrid Recommendations
Hybrid Functionality:
hybrid_recommendations(user_id, title, alpha=0.5):
    Combines Content-Based and Collaborative recommendations.
    Adjusts the importance of each method using a weighting factor alpha.

Implementation:
    Content-based recommendations are obtained for the given movie title.
    Collaborative recommendations are generated for the given user.
    Both recommendations are merged and ranked by their relevance.

6. Example Execution
User Input:
Example user_id: 1 (simulated user).
Example movie_title: 'The Godfather'.

Hybrid Output:
Recommendations are displayed as a ranked list of movies based on their combined scores.

7. Practical Implications
Content-Based Strengths:
Recommends movies based on their inherent attributes, making it effective for new users.
Example: If you like The Godfather, it might recommend Goodfellas due to similar genres or cast members.

Collaborative Strengths:
Leverages user behavior to recommend movies that similar users have liked.
Example: If User A and User B like similar movies, User Aâ€™s favorites can be suggested to User B.

Hybrid Strengths:
Combines the advantages of both approaches to mitigate their individual weaknesses.
Example: Even if a movie lacks sufficient ratings (collaborative data), its content can still be used for recommendations.

Key Components for Practical Examination

Content-Based Filtering:
Understanding of TF-IDF vectorization and cosine similarity.
Ability to explain how movie attributes are used for recommendations.

Collaborative Filtering:
Familiarity with the concept of user-item interaction.
Knowledge of SVD for dimensionality reduction.

Hybrid Recommendations:
Explain how the two methods are combined.
Discuss the importance of balancing content-based and collaborative contributions (alpha).

Practical Output:
Be prepared to demonstrate the script by:
Providing a movie name and user ID.
Explaining the results of the hybrid recommendations.


